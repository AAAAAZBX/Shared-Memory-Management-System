## 共享内存服务技术C++实现

### 服务器程序server.exe

1.初始化的时候分配一块连续内存，假设1G左右，同时对外暴露主机IP以及空闲中的可接收消息的端口号

2.等待客户端clinet.exe发送内存更改请求（当然，前面要进行TCP三次握手验证连接），假设客户端发过来一个字符串，主机检查大小是否够在刚刚已经分配的内存中装下，如果不行，请求失败，否则写入内存

3.后面客户端可以通过发送更改请求，更改主存中的内容

4.可以暂定一个客户端可以申请多块内存，多个客户端不能共享一块内存

5.申请的内存大小加上已有的内存大小不能超过初始化server.exe时的连续内存的大小

6.内存分配可以连续，可以分块，可以使用任何你想使用的方式

7.可以把1G内存分配成为若干个大小固定的块（比如4K），这样就会有256块

8.操作系统定为windows，可以使用`show blocks`命令展示256个内存分配情况，展示表格可以按照下面的格式（单下划线表示没有客户端在占用）

| ID（主键） | Occupied Client(正在占用的客户端) |
| ---------- | --------------------------------- |
| memory_0   | client_1                          |
| 1          | client_1                          |
| 2          | client_2                          |
| 3          | client_2                          |
| 4          | client_1                          |
| 5          | -                                 |
| ...        | ...                               |
| 255        | -                                 |

9.使用`show allocs`命令展示各个内存块所占用的小内存块个数，用上面的例子就是：

| Content（主键） | Memory | Client   |
| --------------- | ------ | -------- |
| string1         | 0-1    | client_1 |
| string2         | 2-3    | client_2 |
| string3         | 4-4    | client_1 |

11.按照从前往后的遍历顺序，如果找不到合适大小的连续内存块，但是空闲内存块大小可以覆盖，则进行“紧凑”，也就是把空闲内存合并后再分配
12.最后也是最重要的一条，服务器端关闭以后，客户端不可以申请或者更改共享内存里面的内容，但是服务器端关闭的一瞬间，需要将里面原有的内容保存到一个位置（数据库也好，缓存，外存也罢），以便下次打开的时候能够恢复上次打开时候的内容。

### 客户端程序client.exe

1.打开以后，可以输入主机IP和端口进行主机间的通信

2.可以选择申请一块共享内存，制定好初始内容和预计大小，建立以后修改过程中不能超过预计大小，否则会修改失败

3.可以修改之间建立好的共享内存

4.可以删除之前申请的共享内存

5.上面这些的前提是主机存在，并且server.exe正在执行，一旦server.exe关闭，则显示连接失败






